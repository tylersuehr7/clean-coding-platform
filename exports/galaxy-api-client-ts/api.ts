/* tslint:disable */
/* eslint-disable */
/**
 * Galaxy API 0.0.0
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Unique identifier of this account.
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * First name of the account of this account.
     * @type {string}
     * @memberof Account
     */
    'first_name'?: string | null;
    /**
     * Last name of the account of this account.
     * @type {string}
     * @memberof Account
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'display_name': string;
    /**
     * Optional. Timestamp in which this account was deactivated.
     * @type {string}
     * @memberof Account
     */
    'deactivated_on'?: string | null;
    /**
     * Indicates that this account must reset their password.
     * @type {boolean}
     * @memberof Account
     */
    'is_reset_password'?: boolean;
    /**
     * Indicates that this account is verified.
     * @type {boolean}
     * @memberof Account
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'updated': string;
}
/**
 * 
 * @export
 * @interface AcquireAccessTokenRequest
 */
export interface AcquireAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AcquireAccessTokenRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AcquireAccessTokenRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AcquireAccessTokenResponse
 */
export interface AcquireAccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof AcquireAccessTokenResponse
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof AcquireAccessTokenResponse
     */
    'refresh': string;
    /**
     * 
     * @type {Account}
     * @memberof AcquireAccessTokenResponse
     */
    'account': Account;
}
/**
 * 
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAccountRequest
     */
    'is_reset_password'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAccountRequest
     */
    'is_verified'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateNewAccountResponse
 */
export interface CreateNewAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateNewAccountResponse
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNewAccountResponse
     */
    'refresh': string;
    /**
     * 
     * @type {Account}
     * @memberof CreateNewAccountResponse
     */
    'account': Account;
}
/**
 * 
 * @export
 * @interface CreateTaskForAccountResponse
 */
export interface CreateTaskForAccountResponse {
    /**
     * 
     * @type {Task}
     * @memberof CreateTaskForAccountResponse
     */
    'task': Task;
}
/**
 * 
 * @export
 * @interface CreateTaskRequest
 */
export interface CreateTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateTaskRequest
     */
    'share_with_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface GetTaskResponse
 */
export interface GetTaskResponse {
    /**
     * 
     * @type {Task}
     * @memberof GetTaskResponse
     */
    'task': Task;
}
/**
 * 
 * @export
 * @interface IntrospectAccessTokenResponse
 */
export interface IntrospectAccessTokenResponse {
    /**
     * 
     * @type {Account}
     * @memberof IntrospectAccessTokenResponse
     */
    'account': Account;
}
/**
 * 
 * @export
 * @interface ListTasksForAccountResponse
 */
export interface ListTasksForAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof ListTasksForAccountResponse
     */
    'next': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListTasksForAccountResponse
     */
    'prev': string | null;
    /**
     * 
     * @type {number}
     * @memberof ListTasksForAccountResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<Task>}
     * @memberof ListTasksForAccountResponse
     */
    'results': Array<Task>;
}
/**
 * 
 * @export
 * @interface RefreshAccessTokenRequest
 */
export interface RefreshAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshAccessTokenRequest
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface RefreshAccessTokenResponse
 */
export interface RefreshAccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshAccessTokenResponse
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshAccessTokenResponse
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface ShareTaskRequest
 */
export interface ShareTaskRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ShareTaskRequest
     */
    'account_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'id': string;
    /**
     * Brief name of this task.
     * @type {string}
     * @memberof Task
     */
    'name': string;
    /**
     * Optional. Description or details of this task.
     * @type {string}
     * @memberof Task
     */
    'description'?: string | null;
    /**
     * Account who owns this task.
     * @type {string}
     * @memberof Task
     */
    'owner_id': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'owner_display_name': string;
    /**
     * 
     * @type {Array<TaskSharedAccount>}
     * @memberof Task
     */
    'shared_with': Array<TaskSharedAccount>;
    /**
     * Optional. Timestamp in which this task was marked completed.
     * @type {string}
     * @memberof Task
     */
    'completed_on'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'updated': string;
}
/**
 * 
 * @export
 * @interface TaskSharedAccount
 */
export interface TaskSharedAccount {
    /**
     * Unique identifier of this account.
     * @type {string}
     * @memberof TaskSharedAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TaskSharedAccount
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface UnshareTaskRequest
 */
export interface UnshareTaskRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UnshareTaskRequest
     */
    'account_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateTaskRequest
 */
export interface UpdateTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTaskRequest
     */
    'completed_on'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTaskRequest
     */
    'deleted_on'?: boolean | null;
}
/**
 * 
 * @export
 * @interface UpdateTaskResponse
 */
export interface UpdateTaskResponse {
    /**
     * 
     * @type {Task}
     * @memberof UpdateTaskResponse
     */
    'task': Task;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewAccount: async (createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createNewAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateNewAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewAccount(createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @param {AccountApiCreateNewAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewAccount(requestParameters: AccountApiCreateNewAccountRequest, options?: AxiosRequestConfig): AxiosPromise<CreateNewAccountResponse> {
            return localVarFp.createNewAccount(requestParameters.createAccountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNewAccount operation in AccountApi.
 * @export
 * @interface AccountApiCreateNewAccountRequest
 */
export interface AccountApiCreateNewAccountRequest {
    /**
     * 
     * @type {CreateAccountRequest}
     * @memberof AccountApiCreateNewAccount
     */
    readonly createAccountRequest: CreateAccountRequest
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @param {AccountApiCreateNewAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createNewAccount(requestParameters: AccountApiCreateNewAccountRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).createNewAccount(requestParameters.createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemaRetrieve: async (format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSchemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSchemaRetrieve(format, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {ApiApiApiSchemaRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemaRetrieve(requestParameters: ApiApiApiSchemaRetrieveRequest = {}, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.apiSchemaRetrieve(requestParameters.format, requestParameters.lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiSchemaRetrieve operation in ApiApi.
 * @export
 * @interface ApiApiApiSchemaRetrieveRequest
 */
export interface ApiApiApiSchemaRetrieveRequest {
    /**
     * 
     * @type {'json' | 'yaml'}
     * @memberof ApiApiApiSchemaRetrieve
     */
    readonly format?: 'json' | 'yaml'

    /**
     * 
     * @type {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'}
     * @memberof ApiApiApiSchemaRetrieve
     */
    readonly lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'
}

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {ApiApiApiSchemaRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSchemaRetrieve(requestParameters: ApiApiApiSchemaRetrieveRequest = {}, options?: AxiosRequestConfig) {
        return ApiApiFp(this.configuration).apiSchemaRetrieve(requestParameters.format, requestParameters.lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public ping(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdentityApi - axios parameter creator
 * @export
 */
export const IdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AcquireAccessTokenRequest} acquireAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acquireAccessToken: async (acquireAccessTokenRequest: AcquireAccessTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acquireAccessTokenRequest' is not null or undefined
            assertParamExists('acquireAccessToken', 'acquireAccessTokenRequest', acquireAccessTokenRequest)
            const localVarPath = `/v1/identity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acquireAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        introspectAccessToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/identity/introspect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Proxy API for the underlying TokenRefreshView – so DRF can see this
         * @param {RefreshAccessTokenRequest} refreshAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken: async (refreshAccessTokenRequest: RefreshAccessTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshAccessTokenRequest' is not null or undefined
            assertParamExists('refreshAccessToken', 'refreshAccessTokenRequest', refreshAccessTokenRequest)
            const localVarPath = `/v1/identity/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityApi - functional programming interface
 * @export
 */
export const IdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AcquireAccessTokenRequest} acquireAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acquireAccessToken(acquireAccessTokenRequest: AcquireAccessTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcquireAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acquireAccessToken(acquireAccessTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async introspectAccessToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntrospectAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.introspectAccessToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Proxy API for the underlying TokenRefreshView – so DRF can see this
         * @param {RefreshAccessTokenRequest} refreshAccessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccessToken(refreshAccessTokenRequest: RefreshAccessTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(refreshAccessTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentityApi - factory interface
 * @export
 */
export const IdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityApiFp(configuration)
    return {
        /**
         * 
         * @param {IdentityApiAcquireAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acquireAccessToken(requestParameters: IdentityApiAcquireAccessTokenRequest, options?: AxiosRequestConfig): AxiosPromise<AcquireAccessTokenResponse> {
            return localVarFp.acquireAccessToken(requestParameters.acquireAccessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        introspectAccessToken(options?: AxiosRequestConfig): AxiosPromise<IntrospectAccessTokenResponse> {
            return localVarFp.introspectAccessToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Proxy API for the underlying TokenRefreshView – so DRF can see this
         * @param {IdentityApiRefreshAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(requestParameters: IdentityApiRefreshAccessTokenRequest, options?: AxiosRequestConfig): AxiosPromise<RefreshAccessTokenResponse> {
            return localVarFp.refreshAccessToken(requestParameters.refreshAccessTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for acquireAccessToken operation in IdentityApi.
 * @export
 * @interface IdentityApiAcquireAccessTokenRequest
 */
export interface IdentityApiAcquireAccessTokenRequest {
    /**
     * 
     * @type {AcquireAccessTokenRequest}
     * @memberof IdentityApiAcquireAccessToken
     */
    readonly acquireAccessTokenRequest: AcquireAccessTokenRequest
}

/**
 * Request parameters for refreshAccessToken operation in IdentityApi.
 * @export
 * @interface IdentityApiRefreshAccessTokenRequest
 */
export interface IdentityApiRefreshAccessTokenRequest {
    /**
     * 
     * @type {RefreshAccessTokenRequest}
     * @memberof IdentityApiRefreshAccessToken
     */
    readonly refreshAccessTokenRequest: RefreshAccessTokenRequest
}

/**
 * IdentityApi - object-oriented interface
 * @export
 * @class IdentityApi
 * @extends {BaseAPI}
 */
export class IdentityApi extends BaseAPI {
    /**
     * 
     * @param {IdentityApiAcquireAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public acquireAccessToken(requestParameters: IdentityApiAcquireAccessTokenRequest, options?: AxiosRequestConfig) {
        return IdentityApiFp(this.configuration).acquireAccessToken(requestParameters.acquireAccessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public introspectAccessToken(options?: AxiosRequestConfig) {
        return IdentityApiFp(this.configuration).introspectAccessToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Proxy API for the underlying TokenRefreshView – so DRF can see this
     * @param {IdentityApiRefreshAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public refreshAccessToken(requestParameters: IdentityApiRefreshAccessTokenRequest, options?: AxiosRequestConfig) {
        return IdentityApiFp(this.configuration).refreshAccessToken(requestParameters.refreshAccessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} accountId 
         * @param {CreateTaskRequest} createTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskForAccount: async (accountId: string, createTaskRequest: CreateTaskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createTaskForAccount', 'accountId', accountId)
            // verify required parameter 'createTaskRequest' is not null or undefined
            assertParamExists('createTaskForAccount', 'createTaskRequest', createTaskRequest)
            const localVarPath = `/v1/accounts{account_id}/tasks`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('deleteTask', 'taskId', taskId)
            const localVarPath = `/v1/tasks/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTask', 'taskId', taskId)
            const localVarPath = `/v1/tasks/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasksForAccount: async (accountId: string, limit?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listTasksForAccount', 'accountId', accountId)
            const localVarPath = `/v1/accounts{account_id}/tasks`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {ShareTaskRequest} shareTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareTask: async (taskId: string, shareTaskRequest: ShareTaskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('shareTask', 'taskId', taskId)
            // verify required parameter 'shareTaskRequest' is not null or undefined
            assertParamExists('shareTask', 'shareTaskRequest', shareTaskRequest)
            const localVarPath = `/v1/tasks/{task_id}/share`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {UnshareTaskRequest} unshareTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareTask: async (taskId: string, unshareTaskRequest: UnshareTaskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('unshareTask', 'taskId', taskId)
            // verify required parameter 'unshareTaskRequest' is not null or undefined
            assertParamExists('unshareTask', 'unshareTaskRequest', unshareTaskRequest)
            const localVarPath = `/v1/tasks/{task_id}/unshare`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unshareTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {UpdateTaskRequest} updateTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (taskId: string, updateTaskRequest: UpdateTaskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('updateTask', 'taskId', taskId)
            // verify required parameter 'updateTaskRequest' is not null or undefined
            assertParamExists('updateTask', 'updateTaskRequest', updateTaskRequest)
            const localVarPath = `/v1/tasks/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} accountId 
         * @param {CreateTaskRequest} createTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskForAccount(accountId: string, createTaskRequest: CreateTaskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTaskForAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskForAccount(accountId, createTaskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTask(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasksForAccount(accountId: string, limit?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTasksForAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTasksForAccount(accountId, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {ShareTaskRequest} shareTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareTask(taskId: string, shareTaskRequest: ShareTaskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareTask(taskId, shareTaskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {UnshareTaskRequest} unshareTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unshareTask(taskId: string, unshareTaskRequest: UnshareTaskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unshareTask(taskId, unshareTaskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {UpdateTaskRequest} updateTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(taskId: string, updateTaskRequest: UpdateTaskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateTaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(taskId, updateTaskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * 
         * @param {TaskApiCreateTaskForAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskForAccount(requestParameters: TaskApiCreateTaskForAccountRequest, options?: AxiosRequestConfig): AxiosPromise<CreateTaskForAccountResponse> {
            return localVarFp.createTaskForAccount(requestParameters.accountId, requestParameters.createTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TaskApiDeleteTaskRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(requestParameters: TaskApiDeleteTaskRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTask(requestParameters.taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TaskApiGetTaskRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(requestParameters: TaskApiGetTaskRequest, options?: AxiosRequestConfig): AxiosPromise<GetTaskResponse> {
            return localVarFp.getTask(requestParameters.taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TaskApiListTasksForAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasksForAccount(requestParameters: TaskApiListTasksForAccountRequest, options?: AxiosRequestConfig): AxiosPromise<ListTasksForAccountResponse> {
            return localVarFp.listTasksForAccount(requestParameters.accountId, requestParameters.limit, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TaskApiShareTaskRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareTask(requestParameters: TaskApiShareTaskRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.shareTask(requestParameters.taskId, requestParameters.shareTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TaskApiUnshareTaskRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareTask(requestParameters: TaskApiUnshareTaskRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unshareTask(requestParameters.taskId, requestParameters.unshareTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TaskApiUpdateTaskRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(requestParameters: TaskApiUpdateTaskRequest, options?: AxiosRequestConfig): AxiosPromise<UpdateTaskResponse> {
            return localVarFp.updateTask(requestParameters.taskId, requestParameters.updateTaskRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTaskForAccount operation in TaskApi.
 * @export
 * @interface TaskApiCreateTaskForAccountRequest
 */
export interface TaskApiCreateTaskForAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof TaskApiCreateTaskForAccount
     */
    readonly accountId: string

    /**
     * 
     * @type {CreateTaskRequest}
     * @memberof TaskApiCreateTaskForAccount
     */
    readonly createTaskRequest: CreateTaskRequest
}

/**
 * Request parameters for deleteTask operation in TaskApi.
 * @export
 * @interface TaskApiDeleteTaskRequest
 */
export interface TaskApiDeleteTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof TaskApiDeleteTask
     */
    readonly taskId: string
}

/**
 * Request parameters for getTask operation in TaskApi.
 * @export
 * @interface TaskApiGetTaskRequest
 */
export interface TaskApiGetTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof TaskApiGetTask
     */
    readonly taskId: string
}

/**
 * Request parameters for listTasksForAccount operation in TaskApi.
 * @export
 * @interface TaskApiListTasksForAccountRequest
 */
export interface TaskApiListTasksForAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof TaskApiListTasksForAccount
     */
    readonly accountId: string

    /**
     * 
     * @type {number}
     * @memberof TaskApiListTasksForAccount
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof TaskApiListTasksForAccount
     */
    readonly page?: number
}

/**
 * Request parameters for shareTask operation in TaskApi.
 * @export
 * @interface TaskApiShareTaskRequest
 */
export interface TaskApiShareTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof TaskApiShareTask
     */
    readonly taskId: string

    /**
     * 
     * @type {ShareTaskRequest}
     * @memberof TaskApiShareTask
     */
    readonly shareTaskRequest: ShareTaskRequest
}

/**
 * Request parameters for unshareTask operation in TaskApi.
 * @export
 * @interface TaskApiUnshareTaskRequest
 */
export interface TaskApiUnshareTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof TaskApiUnshareTask
     */
    readonly taskId: string

    /**
     * 
     * @type {UnshareTaskRequest}
     * @memberof TaskApiUnshareTask
     */
    readonly unshareTaskRequest: UnshareTaskRequest
}

/**
 * Request parameters for updateTask operation in TaskApi.
 * @export
 * @interface TaskApiUpdateTaskRequest
 */
export interface TaskApiUpdateTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof TaskApiUpdateTask
     */
    readonly taskId: string

    /**
     * 
     * @type {UpdateTaskRequest}
     * @memberof TaskApiUpdateTask
     */
    readonly updateTaskRequest: UpdateTaskRequest
}

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * 
     * @param {TaskApiCreateTaskForAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public createTaskForAccount(requestParameters: TaskApiCreateTaskForAccountRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).createTaskForAccount(requestParameters.accountId, requestParameters.createTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TaskApiDeleteTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public deleteTask(requestParameters: TaskApiDeleteTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).deleteTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TaskApiGetTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTask(requestParameters: TaskApiGetTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TaskApiListTasksForAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public listTasksForAccount(requestParameters: TaskApiListTasksForAccountRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).listTasksForAccount(requestParameters.accountId, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TaskApiShareTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public shareTask(requestParameters: TaskApiShareTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).shareTask(requestParameters.taskId, requestParameters.shareTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TaskApiUnshareTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public unshareTask(requestParameters: TaskApiUnshareTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).unshareTask(requestParameters.taskId, requestParameters.unshareTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TaskApiUpdateTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public updateTask(requestParameters: TaskApiUpdateTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).updateTask(requestParameters.taskId, requestParameters.updateTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


